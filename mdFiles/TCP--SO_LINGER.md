---
title: TCP的SO_LINGER选项
category: TCP/IP
---

本文将介绍TCP的SO_LINGER选项。

<!--more-->

---


## SO_LINGER作用
设置函数close()关闭TCP连接时的行为。

缺省时close()的行为是：
如果有数据残留在socket发送缓冲区中则系统将继续发送这些数据给对方，等待被确认，然后返回。

利用此选项，可以将此缺省行为设置为以下两种：
1. 立即关闭该连接，通过发送RST分组(而不是用正常的FIN|ACK|FIN|ACK四个分组)来关闭该连接。至于发送缓冲区中如果有未发送完的数据，则丢弃。主动关闭一方的TCP状态则跳过TIMEWAIT，直接进入CLOSED。
2. 将连接的关闭设置一个超时。如果socket发送缓冲区中仍残留数据，进程进入睡眠，内核进入定时状态去尽量去发送这些数据。在超时之前，如果所有数据都发送完且被对方确认，内核用正常的FIN|ACK|FIN|ACK四个分组来关闭该连接，close()成功返回。如果超时，数据仍然未能成功发送及被确认，用上述1方式来关闭此连接。close()返回EWOULDBLOCK。


## linger结构
```bash
struct linger {
  int l_onoff;
  int l_linger;
}; 
```
l_onoff为 0，则该选项关闭，l_linger的值被忽略，close()用上述缺省方式关闭连接。
l_onoff非 0，l_linger为 0，close()用上述1方式关闭连接。
l_onoff非 0，l_linger非 0，close()用上述2方式关闭连接。


## 异常关闭
终止一个连接的正常方式是发送FIN。在发送缓冲区中所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。但我们有时也有可能发送一个RST报文段而不是FIN来中途关闭一个连接。这称为异常关闭。

如上述的第1种方式，就是通过RST来异常关闭TCP连接。

【注意】
RST报文段不会导致另一端产生任何响应，另一端根本不进行确认。收到RST的一方将终止该连接。程序行为如下：
1. 阻塞模型
内核无法主动通知应用层出错，只有应用层主动调用read()或者write()这样的IO系统调用时，内核才会利用出错来通知应用层对端RST。
2. 非阻塞模型
select或者epoll会返回sockfd可读,应用层对其进行读取时，read()会报错RST。