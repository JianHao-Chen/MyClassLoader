---
title: JVM--类加载的过程
categories: Java笔记
---

有个问题：
反射中Class.forName()和ClassLoader.loadClass()的区别？
回答这个问题，本来以为简单翻一下源码就可以了，其实还是有些概念要去翻一下书。
<!--more-->

---

先看`Class.forName()`的代码：
```
public static Class<?> forName(String className)
        throws ClassNotFoundException {
    return forName0(
        className, 
        true,
        ClassLoader.getClassLoader(Reflection.getCallerClass()));
}
```
注意到forName0的第二个参数(true)，指Class被loading后是不是必须被初始化。
至于什么是<font color=red>*类初始化*</font>，这个等下再说。

再看`loadClass()`方法：
```
public Class<?> loadClass(String name) throws ClassNotFoundException {
    return loadClass(name, false);
}

protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException{
    ...
}
```
注意到使用loadClass方法的boolean参数resolve，表示目标对象是否进行链接，默认即不进行链接。
那这个<font color=red>*链接*</font>又是什么呢？这个等下再说。


## Java类装载过程

<img src="http://img.blog.csdn.net/20171104202906450">

下面简单说说类装载过程吧。

#### 加载
在这个阶段，虚拟机完成3件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据结构的访问入口。

虚拟机规范的这3点要求并不具体，因此虚拟机的实现灵活度很大。
例如：
1) 第一点，没有明确二进制字节流从哪里获取。

* 从ZIP包获取，如JAR，WAR格式
* 从网络获取，其应用是Applet
* 运行时计算生成，使用这种技术的是动态代理

2) 第二点，虚拟机规范没有规定这个运行时数据结构的内容。
3) 第三点，没有规定生成的这个Class对象存放在Java堆中，实际上，HotSpot虚拟机的实现就把它放在方法区。

请记住：<font color=red>加载阶段与链接阶段的部分内容是交叉进行的，加载阶段尚未完成，链接阶段可能已经开始。</font>


#### 验证
验证是链接阶段的第一步，它的目的是为了<font color=blue>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</font>
验证包含以下4个阶段：

1. 文件格式验证
判断字节流是否符合Class文件格式的规范，如：
 * 是否以魔数开头
 * 主次版本号是否在当前虚拟机的处理范围之内
 * 常量池的常量是否存在不被支持的常量类型（检查常量tag标志）
 * 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
 * 。。。（省略）

2. 元数据验证
这个阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合**Java语言规范**的要求，如：
 * 这个类是否有父类(除了java.lang.Object之外，所有的类都应该有父类)
 * 这个类是否继承了不允许被继承的类（被final修饰的类）
 * 如果这个类不是抽象类，是否实现了其父类或接口要求实现的所有方法。
 * 。。。（省略）

3. 字节码验证
主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。
上面对元数据信息校验完后，这个阶段对方法体进行校验，保证方法在运行时不会做出危害虚拟机的事情，例如：
 * 保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作，不会出现类似“在操作栈放一个int类型的数据，使用时却按long类型来加载入本地变量表”
 * 跳转指令不会跳转到方法体以外的字节码指令上
 * 。。。（省略）

4. 符号引用验证
这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段发生。
符号引用验证可以看作是对类自身以为（常量池中的各种符合引用）的信息进行匹配性校验，如：
 * 符号引用中通过字符串描述的全限定名是否能找到对应的类
 * 在指定的类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
 * 符号引用中的类、字段、方法的访问性（private , protected , public）是否可以被当前类访问
 * 。。。（省略）


<font color=red>**注意:**</font>
<font color=orange>文件格式验证阶段是对二进制流的，只有通过了这个阶段的验证，字节流才会进入内存的方法区进行存储，所以后面3个验证都是对方法区的存储结构进行的。</font>


#### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在**方法区**进行分配。
<font color=red>注意:</font>

1. 这里进行内存分配的变量是**类变量**，而不是**实例变量**！
2. 设置类变量初始值，是指数据类型的零值

假设有一个类变量的定义为`public static int value = 123;`，那么这里value在准备阶段后，初始值是0，而不是123！
**而把value赋值为123的putstatic指令，是程序被编译后，存放到类构造器`<cinit>()`方法之中，因此把value赋值为123的动作将在初始化阶段才会执行。**


#### 解析
解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。

<font color=green>符号引用</font>
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。

<font color=green>直接引用</font>
直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在于内存了。



#### 初始化
初始化阶段是执行类构造器`<clinit>()`方法的过程。

 * `<clinit>()`方法是由编译器收集类变量的赋值语句和静态语句块的语句合并产生的。
 * 虚拟机会保证子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕。
 * 父类的静态语句块肯定优先于子类的静态语句块。

---


前面说到，Class.forName(className)方法，是需要**类初始化**的。而ClassLoader.loadClass(className)方法，是不需要**链接**的。
现在就可以解释它们的区别了：

1. **类初始化**，表示类加载过程会执行到“初始化”阶段，那么前面的“加载”、“链接”阶段当然是要执行的。
2. 不执行**链接**阶段，表示只是获取这个类的二进制流，转化为方法区的运行时数据结构，在内存中生成 Class对象。










