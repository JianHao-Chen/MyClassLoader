---
title: TCP数据的发送
category: TCP/IP
---

我们调用诸如send或者write方法来发送数据到另一台主机，那么，调用这样的方法时，在操作系统内核中发生了什么事情呢？

<!--more-->

---

## MSS与TCP的分片

#### 最大传输单元MTU
无论何种类型的数据链路层，都会对网络分组的长度有一个限制。例如以太网限制为1500字节，802.3限制为1492字节。当内核的IP网络层试图发送报文时，若一个报文的长度大于MTU限制，就会被分成若干个小于MTU的报文，每个报文都会有独立的IP头部。

IP包总长度的是一个16位（2字节）的字段,这意味一个IP包最大可以是65535字节。

若TCP层在以太网中试图发送一个大于1500字节的消息，调用IP网络层方法发送消息时，IP层会自动的获取所在局域网的MTU值，并按照所在网络的MTU大小来分片。IP层同时希望这个分片对于传输层来说是透明的，接收方的IP层会根据收到的多个IP包头部，将发送方IP层分片出的IP包重组为一个消息。

这种IP层的分片效率是很差的，因为必须所有分片都到达才能重组成一个包，其中任何一个分片丢失了，都必须重发所有分片。所以，TCP层会试图避免IP层执行数据报分片。

#### 最大报文段长度MSS
为了避免IP层的分片，TCP协议定义了一个新的概念：最大报文段长度MSS。它定义了一个TCP连接上，一个主机期望对端主机发送单个报文的最大长度。TCP建立3次握手连接时，连接双方都要互相告知自己期望接收到的MSS大小。

这个MSS是预估的，TCP连接上的两台主机若处于不同的网络中，那么，连接上可能有许多中间网络，这些网络分别具有不同的数据链路层，这样，TCP连接上有许多个MTU。特别是，若中间途径的MTU小于两台主机所在的网络MTU时，选定的MSS仍然太大了，会导致中间路由器出现IP层的分片。

怎样避免中间网络可能出现的分片呢？
通过IP头部的DF标志位，这个标志位是告诉IP报文所途经的所有IP层代码：不要对这个报文分片。如果一个IP报文太大必须要分片，则直接返回一个ICMP错误，说明必须要分片了，且待分片路由器网络接受的MTU值。这样，连接上的发送方主机就可以重新确定MSS。



## TCP是如何保证可靠传输的
TCP把自己要发送的数据流里的每一个字节都看成一个序号，可靠性是要求连接对端在接收到数据后，要发送ACK确认，告诉它已经接收到了多少字节的数据。


## TCP发送消息的流程

<img src="http://img.blog.csdn.net/20170521220516677">

上图分为10步：
(1) 应用程序试图调用send方法来发送一段较长的数据

(2) 内核主要通过tcp_sendmsg方法来完成。

(3) 把用户需要发送的用户态内存中的数据，拷贝到内核态内存中。
A. 拷贝到内核态内存,是为了不依赖于用户态内存，也使得进程可以快速释放发送数据占用的用户态内存。
B. 这个拷贝操作并不是简单的复制，而是把待发送数据，按照MSS来划分成多个尽量达到MSS大小的分片报文段，复制到内核中的sk_buff结构来存放，同时把这些分片组成队列，放到这个TCP连接对应的tcp_write_queue发送队列中。

(4) 内核中为这个TCP连接分配的内核缓存是有限的.当没有多余的内核态缓存来复制用户态的待发送数据时，就需要调用一个方法sk_stream_wait_memory来等待滑动窗口移动，释放出一些缓存出来（收到ACK后，不需要再缓存原来已经发送出的报文，因为既然已经确认对方收到，就不需要定时重发，自然就释放缓存了）。
```bash
wait_for_memory:  
  if (copied)  
    tcp_push(sk, tp, flags & ~MSG_MORE, mss_now, TCP_NAGLE_PUSH);
    
  if ((err = sk_stream_wait_memory(sk, &timeo)) != 0)  
    goto do_error;  
```
sk_stream_wait_memory方法接受一个参数timeo，就是等待超时的时间 ,这个时间是 tcp_sendmsg 方法刚开始就拿到的，如下：
```bash
timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);
```
看看其实现：
```bash
static inline long sock_sndtimeo(const struct sock *sk, int noblock) {  
  return noblock ? 0 : sk->sk_sndtimeo;  
}
```
当这个套接字是阻塞套接字时，timeo就是SO_SNDTIMEO选项指定的发送超时时间。
当这个套接字是非阻塞套接字，timeo变量就会是0。
sk_stream_wait_memory会直接返回，并将 errno错误码置为EAGAIN。


(5) 


