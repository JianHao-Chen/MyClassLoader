---
title: TCP连接的建立
category: TCP/IP
---

本文将介绍TCP的连接的建立。

<!--more-->

---

## TCP的三次握手
<img src="http://img.blog.csdn.net/20170521181710561">

对图中的值x，y的解析：
它们都是ISN，当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。这样选择序号的目的是防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

【注意】
client端发送数据的第一字节序号为 x+1，因为SYN标志是要消耗一个序号的。
我们可以看到server端的确认序号为 x+1，表示server期望收到client的下一个序号是x+1。

#### 三次握手的原因

★ 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

所谓“已失效的连接请求报文段”会在这样一种情况下产生：
client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。
采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。


## TCP建立连接的实现

<img src="http://img.blog.csdn.net/20170521184542936">

对上图的解释：
1. 客户端使用connect向服务器发起TCP连接，当图中1.1步骤客户端的SYN包到达了服务器后，内核会把这一信息放到SYN队列（即未完成握手队列）中，同时回一个SYN+ACK包(图中1.3步骤)给客户端。
2. 一段时间后，在较中2.1步骤中客户端再次发来了针对服务器SYN包的ACK网络分组时，内核会把连接从SYN队列中取出，再把这个连接放到ACCEPT队列（即已完成握手队列）中。
3. 服务器在第3步调用accept时，其实就是直接从ACCEPT队列中取出已经建立成功的连接套接字而已。

#### listen()函数
```bash
#include<sys/socket.h>
int listen(int sockfd, int backlog);
```
listen函数仅由TCP服务器调用，它做两件事情：
1. listen函数把一个未连接的套接口转换成一个被动套接口，指示内核应接受指向该套接口的连接请求。(当使用socket函数创建一个套接口时，它被假设为一个主动套装口)，调用listen导致套接口从CLOSED状态转换到LISTEN状态。
2. 本函数的第二个参数规定了内核应该为相应套接口排队的最大连接个数。

listen函数的**backlog**参数：
是已连接但未进行accept处理的SOCKET队列大小,即已完成连接队列的大小。

【补充】
内核为任何一个给定的监听套接口维护两个队列：
1. 未完成连接队列
客户端的SYN包到达了服务器后，内核会把这一信息放到SYN队列（即未完成握手队列）
2. 已完成连接队列
每个已完成TCP三路握手的客户对应其中一项。这些套接口处于ESTABLISHED状态。


#### 队列满的情况
SYN队列和ACCEPT队列都不是无限长度的，它们的长度限制与调用listen监听某个地址端口时传递的backlog参数有关。
如果上图中第1步执行的速度大于第2步执行的速度，SYN队列就会不断增大直到队列满；如果第2步执行的速度远大于第3步执行的速度，ACCEPT队列同样会达到上限。第1、2步不是应用程序可控的，但第3步却是应用程序的行为，假设进程中调用accept获取新连接的代码段长期得不到执行，例如获取不到锁、IO阻塞等。

若SYN队列满，则会直接丢弃请求，即新的SYN网络分组会被丢弃。
如果ACCEPT队列满，则不会导致放弃连接，也不会把连接从SYN列队中移出，这会加剧SYN队列的增长。

所以，对应用服务器来说，如果ACCEPT队列中有已经建立好的TCP连接，却没有及时的把它取出来，这样，一旦导致两个队列满了后，就会使客户端不能再建立新连接，引发严重问题。所以，如TOMCAT等服务器会使用独立的线程，只做accept获取连接这一件事，以防止不能及时的去accept获取连接。


