---
title: synchronized的实现原理
categories: Java笔记
---

synchronized，被叫做重量级锁。下面将介绍它的实现原理。

<!--more-->

---

## Java对象头
synchronized用的锁是存在Java对象头里的。关于对象头,有以下知识点:

☆ 对象在堆里的逻辑结构 :
  { 对象头 , 实例变量 }
  
☆ 如果对象是数组类型,虚拟机使用3个字宽存储对象头(用于存储数组长度),否则使用2个字宽。32位机下，1字宽  = 4字节

☆ 对象头的结构 :

  * Mark Word  (存储对象的hashCode 或锁信息)
  * Class Metadata Address (存储到对象类型数据的指针)
  * Array Length (数组的长度(如果当前对象是数组))
  
对象头的信息都是与对象自身定义的数据无关的额外存储成本,考虑到虚拟机的空间效率,Mark Word被设计成一个非固定的数据结构以便尽量存储多点信息,它会根据对象锁的状态复用自己的存储空间。

☆ Mark Word的状态变化

在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。
| 存储内容         | 标志位           | 状态  |
| ------------- |:-------------:| -----:|
| 对象哈希码、对象分代年龄      | 01 | 未锁定 |
| 指向锁记录的指针      | 00      |   轻量级锁定 |
| 指向重量级锁的指针 | 10      |    膨胀(重量级锁定) |
| 空,不需要记录信息   |  11      |    GC标记 |
| 偏向线程的ID、偏向时间戳、对象分代年龄   |  01      |    可偏向 |

Mark Word里有一个bit用于指示"是否是偏向锁",以此可以区分"未锁定"和"可偏向"


## 锁的升级
**为了减少获得锁和释放锁的开销,引入"偏向锁"和"轻量级锁"。**

Java1.6中,锁一共有4种状态,级别从低到高分别是:
`无锁状态 -> 偏向锁状态 -> 轻量级锁状态 -> 重量级锁状态`

这几个状态会随着竞争情况逐渐升级,锁可以升级但不能降级。

#### 偏向锁
大多数情况,锁不但不存在多线程竞争,而且总是由同一个线程多次获得,为了降低获得锁的代价引入偏向锁。

★ 偏向锁的获取
1. 线程进入同步块，查看对象头Mark Word的锁标志位，如果是“01”，表示未锁定或可偏向，进行偏向锁的获取。
2. 查看“是否是偏向锁”的bit位，如果是0，表示未锁定。进入步骤3。如果是1，表示当前已经是偏向锁，进入步骤4。
3. 执行CAS操作，替换 ThreadID。如果成功，表示已经获得偏向锁。如果失败，需要执行【偏向锁的撤销】。
4. 检查对象头的Mark Word中记录的是不是当前线程ID，如果是表示已经获得偏向锁。否则，进入步骤3。

★ 偏向锁的撤销
偏向锁使用一种等到竞争出现才释放锁的机制。偏向锁的撤销需要等待全局安全点(这个时候没有正在执行的字节码)。
1. JVM会挂起拥有偏向锁的线程,检查这个线程是否活着，如果这个线程不是活动状态或已经退出同步块，那么进入步骤2。否则进入步骤3。
2. 将对象头设置为无锁状态，并且唤醒原拥有偏向锁的线程。然后继续尝试获取偏向锁，即进入获取偏向锁的第4步。
3. 执行【升级为轻量级锁】的操作。

<font color=blue>补充 :</font>
偏向锁的释放不需要做任何事情,这也就意味着加过偏向锁的Mark Word会一直保留偏向锁的状态,因此即便同一个线程持续不断地加锁解锁，也是没有开销的。

#### 轻量级锁
引入的目的是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。

★ 轻量级锁的获取

☆ 情况1 (线程进入同步块)
1. 线程进入同步块，查看对象头Mark Word的锁标志位，如果是“00”，表示当前已经是轻量级锁，进行轻量级锁的获取。
2. 首先在当前线程的栈帧中创建用于存储锁记录的空间，并拷贝对象头中的Mark Word到当前线程的锁记录中。
3. 通过CAS操作将对象头的Mark Word替换成指向锁记录的指针。如果成功，即获得轻量级锁。否则，进入步骤4。
4. 通过自旋，重复步骤3，失败一定次数后，执行【升级为重量级锁】。

☆ 情况2 (获取偏向锁失败升级为轻量级锁)
1. 在原持有偏向锁的线程的栈帧中创建用于存储锁记录的空间，并拷贝对象头中的Mark Word到这个线程的锁记录中，这样这个线程就获得轻量级锁。
2. 原持有偏向锁的线程被JVM唤醒，在安全点处继续执行。当前线程则