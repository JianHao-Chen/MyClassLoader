---
title: TCP连接的关闭
category: TCP/IP
---

本文将介绍TCP连接的关闭，及相关实现的原理。

<!--more-->

---

## TCP的四次握手

<img src="http://img.blog.csdn.net/20170522152505824">

#### 主动关闭端的状态转换

1. 应用层调用close函数发起关闭连接请求
2. 发送FIN到对端，关闭写通道，自己进入FIN_WAIT1状态
3. 等待对端的确认ACK到来，接受到ACK后进入FIN_WAIT2状态，如果在超时时间内没有收到确认ACK直接进入CLOSED状态
4. 如果在FIN_WAIT1状态时收到了对端的FIN则进入CLOSING状态（双发都发出了关闭连接请求）
5. 在FIN_WAIT2接受到了对端FIN后进入TIME_WAIT状态，如果在超时时间内没有收这个FIN则直接进入CLOSED状态
6. 在TIME_WAIT状态等待2个MSL（2个报文最长存活周期）后进入CLOSED状态


#### 被动关闭端的状态转换

1. 收到对端FIN后，关闭读通道进入CLOSE_WAIT状态
2. 在CLOSE_WAIT状态等待应用层调用close函数关闭连接
3. 如果在超时时间内调用了close,则进入LAST_ACK状态;否则直接进入CLOSED状态
4. 在LAST_ACK状态，发送FIN到对端并等待对端的确认ACK
5. 如果在超时时间内收到了确认ACK则进入CLOSED状态，否则直接进入CLOSED状态


#### 状态分析

**(1) FIN_WAIT1**
这个状态在实际的工作中很少见。主动方调用close函数关闭连接后立刻进入FIN_WAIT1状态，此时只要收到对端确认ACK后马上会进入FIN_WAIT2状态。因为对端确认ACK是TCP协议栈自己控制的，所以很快就会发出。这个状态如果超时，将直接进入CLOSED状态。

出现场景：
主动方等待ACK过程中网络断掉了，导致长时间收不到ACK，主动方就会停留在CLOSE_WAIT1状态上（超时时间：一般默认60s超时）。

**(2) FIN_WAIT2**
这个状态比较常见。主动端在等待对端FIN到来过程中，会一直保持这个状态（超时时间：一般默认是60s）。由于网络中断，或者对端很忙还没来得及发送FIN、或者对端有bug忘记关闭连接等都会导致主动端长时间处于FIN_WAIT2状态。如果主动方发现大量FIN_WAIT2状态时，应该引起相关人员的注意，这可能是网络不稳、对端程序bug的表现。这个状态如果超时，将直接进入CLOSED状态。


**(3) TIME_WAIT**
这个状态最常见。主动方收到对端的FIN后进入TIME_WAIT状态。然后发送最后一个确认ACK到对端。之后等待2个最大的报文存活周期，正常的关闭流程客户端TCP连接都会经过这个状态，最终进入CLOSED状态。所以我们使用netstat -anpt命令发现客户端有很多的TIME_WAIT，一般这是正常的现象。

TIME_WAIT状态 也叫 "2MSL等待状态", MSL(Maximum Segment Lifetime)， 最大报文生存时间。在此状态的时候,任何迟到的报文都会被丢弃。

等待2MSL的原因：
1. 保证残留网络报不会被新连接接收而产生数据错乱。由于自己上一次发送的数据包可能还残留在网络中，等待2MSL时间可以保证所有残留的网络报在自己关闭前都已经超时。
2. 确保自己最后ACK发到对端。因为ACK发送也可能会失败，这是对端会重新发送FIN，如果已经CLOSED了那么对端将收到RST而不是ACK了，这不符合TCP可靠关闭策略。

注意：
这个状态的连接还没有真正关闭，所以占用的文件句柄和端口号等资源也没有释放。如果TIME_WAIT状态的连接过多，将会导致文件句柄或者端口号等资源不足。


**(4) CLOSE_WAIT**
这个状态表明TCP连接等待被关闭。只可能在被动方出现。如果被动方存在大量的CLOSE_WAIT状态就需要我们特别注意了。我们要仔细研究确认为什么被动方迟迟不愿关闭连接（或许是我们程序中的bug开启了连接，用完后却忘记关闭）


**(5) LAST_ACK**
这个状态只可能在被动端出现。当被动端调用close接口关闭连接后便会进入这个状态，同时发送一个FIN给对端。在接受对端的ACK确认后便会进入CLOSED状态，这个状态一般不易出现，除非网络中断，一般对端会很快给与响应的。





## close的主要流程
TCP连接的关闭有两个方法close和shutdown。我们只讨论close。

#### 关闭的是监听句柄
用于listen的监听句柄也是使用close关闭，关闭这样的句柄含义当然很不同，它本身并不对应着某个TCP连接，但是，附着在它之上的却可能有半成品连接,就是在3此握手时服务端还没有收到客户端的ACK包的连接。

(1) close 首先会移除keepalive定时器。keepalive功能常用于服务器上，防止僵死、异常退出的客户端占用服务器连接资源。移除此定时器后，若ESTABLISH状态的TCP连接在tcp_keepalive_time时间（如服务器上常配置为2小时）内没有通讯，服务器就会主动关闭连接。

(2) 关闭每一个半连接。如何关闭半连接？这时当然不能发FIN包，即正常的四次握手关闭连接，而是会发送RST复位标志去关闭请求。处理完所有半打开的连接close的任务就基本完成了。


#### 关闭的是普通ESTABLISH状态的句柄(未设置so_linger)
首先检查是否有接收到却未处理的消息。

(1) 如果close调用时存在收到远端的、没有处理的消息
这时根据close这一行为的意义，是要丢弃这些消息的。但丢弃消息后，意味着连接远端误以为发出的消息已经被本机收到处理了（因为ACK包确认过了），但实际上确是收到未处理，此时也不能使用正常的四次握手关闭，而是会向远端发送一个RST非正常复位关闭连接。所以，这也要求我们程序员在关闭连接时，要确保已经接收、处理了连接上的消息。

(2) 如果此时没有未处理的消息
进入发送FIN来关闭连接的阶段。这时，先看看是否有待发送的消息。前一篇已经说过，发消息时要计算滑动窗口、拥塞窗口、angle算法等，这些因素可能导致消息会延迟发送的。
1. 如果有待发送的消息，那么要尽力保证这些消息都发出去的。所以，会在最后一个报文中加入FIN标志，同时，关闭用于减少网络中小报文的angle算法，向连接对端发送消息。
2. 如果没有待发送的消息，则构造一个报文，仅含有FIN标志位，发送出去关闭连接。


#### 关闭的是普通ESTABLISH状态的句柄(设置so_linger)

为何要有so_linger这个功能？
